knitr::opts_chunk$set(echo = TRUE)
sodium <- read.table("sodium.txt", header=TRUE)
sodium <- read.table("sodium.txt", header=TRUE)
head(sodium)
knitr::opts_chunk$set(echo = TRUE)
mu <- 0:6
sigma <- 1:10
ll2 <- function(theta1, theta2) {
# if(length(theta1) < length(theta2)) {
#    theta1 <- rep(theta1, len=length(theta2))
# }
#
# if(length(theta2) < length(theta1)) {
#     theta2 <- rep(theta2, len=length(theta1))
# }
#
# ans <- numeric(length(theta1))
#
# for(i in 1:length(ans)) {
#  ans[i] <- sum(dnorm(weight, theta1[i], theta2[i], log=TRUE))
# }
#
# ans
## Recycle arguments
n = length(weight)
m = max(length(theta1), length(theta2))
if(length(theta1) < m)
theta1 = rep(theta1, len=m)
if(length(theta2) < m)
theta2 = rep(theta2, len=m)
## Vector calculation
ans = dnorm(
rep(weight, m),
rep(theta1, each=n),
rep(theta2, each=n),
log=TRUE
)
dim(ans) = c(n, m)
colSums(ans)
}
z <- outer(mu, sigma, ll2)
sodium <- read.table("sodium.txt", header=TRUE)
head(sodium)
getObservation <- function (df){
mat <- df
matResult <- mat[1,]
for(row in 1:nrow(mat)) {
vec <- mat[row,]
exist <- FALSE
for (r in 1:nrow(matResult)) {
if (
vec["Instructor"][,1] == matResult [r,]["Instructor"][,1]
& vec["Supplement"][,1] == matResult[r,]["Supplement"][,1]
) {
exist <- TRUE
break
}
}
if (!exist) {
matResult <- rbind(matResult, vec)
}
}
matResult
}
mat <- getObservation(sodium)
sodiumMat <- with(mat, {
out <- matrix(
nrow=nlevels(Instructor),
ncol=nlevels(Supplement),
dimnames=list(Instructor= levels(Instructor), Supplement = levels(Supplement)))
out[cbind(Instructor, Supplement)] <- Sodium
out
})
sodiumMat
twoway <- function(y) {
mu <- mean(y)
y <- y - mu
alpha <- apply(y, 1, mean)
y <- sweep(y, 1, alpha)
beta <- apply(y, 2, mean)
y <- sweep(y, 2, beta)
list(overall=mu, rows=alpha, cols=beta, residuals=y)
}
twoway(sodiumMat)
## Annette Dobson (1990) "An Introduction to Generalized Linear Models".
## Page 9: Plant Weight Data.
## Control = standard conditions
## Treatment = nutrient rich
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
(sigma <- sd(weight))
like <- function(x, mu) {
den <- dnorm(x, mu, sd(x))
prod(den)
}
like(weight, 0)
like(weight, 4)
like <- function(x, mu) {
den <- dnorm(x, mu, sd(x))
prod(den)
}
like(weight, 0)
like(weight, 4)
like <- function(x, mu) {
den <- dnorm(x, mu, sd(x))
plot(x, den, type="h", xlab = "weight", ylab = "density", main = paste("? = ", mu))
prod(den)
}
like(weight, 0)
like(weight, 4)
like <- function(x, mu) {
likelihood <- 0
counter <- 1
for (m in mu) {
den <- dnorm(x, m, sd(x))
likelihood[counter] <- prod(den)
counter <- counter + 1
}
plot(mu, likelihood, type="l", xlab = "?", ylab = "likelihood")
}
like(weight, seq(0, 6, .01))
loglike <- function(x, mu) {
den <- dnorm(x, mu, sd(x), log = TRUE)
plot(x, den, type="h", xlab = "weight", ylab = "density", main = paste("? = ", mu))
sum(den)
}
loglike(weight, 0)
loglike(weight, 4)
logLike <- function(x, mu) {
likelihood <- 0
counter <- 1
for (m in mu) {
likelihood[counter] <- sum(dnorm(x, m, sd(x), log = TRUE))
counter <- counter + 1
}
plot(mu, likelihood, type="l", xlab = "?", ylab = "likelihood")
}
logLike(weight, seq(0, 6, .01))
likelihood <- 0
counter <- 1
mu <- seq(0, 6, .01)
for (m in mu) {
likelihood[counter] <- sum(dnorm(weight, m, sd(weight), log = TRUE))
counter <- counter + 1
}
ll <- function(theta) {
sum(dnorm(weight, theta[1], theta[2], log=TRUE))
}
maxMu <- mu[which.max(likelihood)]
z <- optim(c(maxMu, sd(weight)), ll, control = list(fnscale=-1))
muMLE <- z$par[1]
muMLE
mean(weight)
dllike <- function (mu) {
sd(weight) * sum(weight - mu)
}
z <- uniroot(dllike, lower=0, upper=6)
z$root
loglike2 <- function(x, mean, sd) {
fn <- dnorm(x, mean, sd, log = TRUE)
plot(x, fn, type="h", xlab = "weight", ylab = "density", main = bquote(mu == .(mean) ~ "; " ~ sigma == .(sd)))
sum(fn)
}
loglike2(weight, 0, 1)
loglike2(weight, 4, 1)
logLike2 <- function(x, mu, sigma) {
likelihood <- 0
counter <- 1
for (m in mu) {
likelihood[counter] <- sum(dnorm(x, m, sigma, log = TRUE))
counter <- counter + 1
}
plot(mu, likelihood, type="l", xlab = "?", ylab = "likelihood", main= bquote(sigma == .(sigma)))
}
logLike2(weight, seq(0, 6, .01), 1)
logLike2(weight, seq(0, 6, .01), .5)
mu <- 0:6
sigma <- 1:10
ll2 <- function(theta1, theta2) {
# if(length(theta1) < length(theta2)) {
#    theta1 <- rep(theta1, len=length(theta2))
# }
#
# if(length(theta2) < length(theta1)) {
#     theta2 <- rep(theta2, len=length(theta1))
# }
#
# ans <- numeric(length(theta1))
#
# for(i in 1:length(ans)) {
#  ans[i] <- sum(dnorm(weight, theta1[i], theta2[i], log=TRUE))
# }
#
# ans
## Recycle arguments
n = length(weight)
m = max(length(theta1), length(theta2))
if(length(theta1) < m)
theta1 = rep(theta1, len=m)
if(length(theta2) < m)
theta2 = rep(theta2, len=m)
## Vector calculation
ans = dnorm(
rep(weight, m),
rep(theta1, each=n),
rep(theta2, each=n),
log=TRUE
)
dim(ans) = c(n, m)
colSums(ans)
}
z <- outer(mu, sigma, ll2)
i <- which(z == max(z), TRUE)
theta <- c(mu[i[1]], sigma[i[2]])
ll <- function(theta) {
sum(dnorm(weight, theta[1], theta[2], log=TRUE))
}
z <- suppressWarnings(optim(theta, ll, control = list(fnscale=-1), method="BFGS", hessian = TRUE))
muSigmaMLE <- z$par
muSigmaMLE
mu <- 0:6
sigma <- 1:10
ll2 <- function(theta1, theta2) {
# if(length(theta1) < length(theta2)) {
#    theta1 <- rep(theta1, len=length(theta2))
# }
#
# if(length(theta2) < length(theta1)) {
#     theta2 <- rep(theta2, len=length(theta1))
# }
#
# ans <- numeric(length(theta1))
#
# for(i in 1:length(ans)) {
#  ans[i] <- sum(dnorm(weight, theta1[i], theta2[i], log=TRUE))
# }
#
# ans
## Recycle arguments
n = length(weight)
m = max(length(theta1), length(theta2))
if(length(theta1) < m)
theta1 = rep(theta1, len=m)
if(length(theta2) < m)
theta2 = rep(theta2, len=m)
## Vector calculation
ans = dnorm(
rep(weight, m),
rep(theta1, each=n),
rep(theta2, each=n),
log=TRUE
)
dim(ans) = c(n, m)
colSums(ans)
}
z <- outer(mu, sigma, ll2)
i <- which(z == max(z), TRUE)
theta <- c(mu[i[1]], sigma[i[2]])
ll <- function(theta) {
sum(dnorm(weight, theta[1], theta[2], log=TRUE))
}
z <- suppressWarnings(optim(theta, ll, control = list(fnscale=-1), method="BFGS", hessian = TRUE))
muSigmaMLE <- z$par
muSigmaMLE
gp <- as.numeric(group) - 1
beta0 <- seq(0, 6, length.out = length(gp))
beta1 <- seq(0, 6, length.out = length(gp))
sigma <- seq(1, 10, length.out = length(gp))
ll3 <- function(theta1, theta2, theta3) {
if(length(theta1) < length(gp)) {
theta1 <- rep(theta1, len=length(gp))
}
if(length(theta1) < length(gp)) {
theta1 <- rep(theta1, len=length(gp))
}
## Recycle arguments
n = length(weight)
m = max(length(theta1), length(theta2))
## Vector calculation
ans = dnorm(
rep(weight, m),
rep(theta1, each=n),
rep(theta2, each=n),
log=TRUE
)
dim(ans) = c(n, m)
colSums(ans)
# ans = numeric(length(theta1))
#
# for(i in 1:length(ans)) {
#   density <- dnorm(weight, theta1[i], theta2[i], log=TRUE)
#   ans[i] = sum(density)
# }
#
# ans
}
mu <- numeric(length(gp))
for(i in 1:length(gp)) {
mu[i] <- beta0[i] + gp[i] * beta1[i]
}
z <- outer(mu, sigma, ll3)
i <- which(z == max(z), TRUE)
theta <- c(beta0[i[1]], beta1[i[1]], sigma[i[2]])
ll <- function(theta) {
sum(dnorm(weight, theta[1] + gp * theta[2] , theta[3], log=TRUE))
}
z <- suppressWarnings(optim(theta, ll, control = list(fnscale=-1), method="BFGS", hessian = TRUE))
(params <- z$par)
lm.D9 <- lm(weight ~ group)
coef(lm.D9)
logLike <- function(x, mu) {
likelihood <- 0
counter <- 1
for (m in mu) {
likelihood[counter] <- sum(dnorm(x, m, sd(x), log = TRUE))
counter <- counter + 1
}
plot(mu, likelihood, type="l", xlab = bquote(mu), ylab = "likelihood")
}
logLike(weight, seq(0, 6, .01))
loglike <- function(x, mu) {
den <- dnorm(x, mu, sd(x), log = TRUE)
plot(x, den, type="h", xlab = "weight", ylab = "density", main = bquote(mu == .(mu)))
sum(den)
}
loglike(weight, 0)
loglike(weight, 4)
like <- function(x, mu) {
den <- dnorm(x, mu, sd(x))
plot(x, den, type="h", xlab = "weight", ylab = "density", main = bquote(mu == .(mu)))
prod(den)
}
like(weight, 0)
like(weight, 4)
logLike3 <- function(x, gp, beta0, beta1, sigma) {
likelihood <- 0
counter <- 1
for (b in beta0) {
mu <- b + gp * beta1
likelihood[counter] <- sum(dnorm(x, mu, sigma, log = TRUE))
counter <- counter + 1
}
plot(beta0, likelihood, type="l", xlab = bquote(beta ~ "0"), ylab = "Log-Likelihood", main = bquote( beta ~ "1" == .(beta1) ~ "; " ~ sigma == .(sigma)))
}
gp <- as.numeric(group) - 1
logLike3(weight, gp, seq(0, 6, .01), 1, 1)
logLike3(weight, gp, seq(0, 6, .01), 0, 1)
loglike3 <- function (weight, gp, beta0, beta1, sigma) {
mu <- beta0 + gp * beta1
logDensity <- dnorm(weight, mu, sigma, log = TRUE)
plot(weight, logDensity, type="h", xlab = "weight", ylab = "log density", main = bquote(beta ~ "0" == .(beta0) ~ "; " ~ beta ~ "1" == .(beta1) ~ "; " ~ sigma == .(sigma)))
sum(logDensity)
}
gp <- as.numeric(group) - 1
loglike3(weight, gp, 0, 1, 1)
loglike3(weight, gp, 4, 1, 1)
logLike2 <- function(x, mu, sigma) {
likelihood <- 0
counter <- 1
for (m in mu) {
likelihood[counter] <- sum(dnorm(x, m, sigma, log = TRUE))
counter <- counter + 1
}
plot(mu, likelihood, type="l", xlab = bquote("mu"), ylab = "likelihood", main= bquote(sigma == .(sigma)))
}
logLike2(weight, seq(0, 6, .01), 1)
logLike2(weight, seq(0, 6, .01), .5)
logLike2 <- function(x, mu, sigma) {
likelihood <- 0
counter <- 1
for (m in mu) {
likelihood[counter] <- sum(dnorm(x, m, sigma, log = TRUE))
counter <- counter + 1
}
plot(mu, likelihood, type="l", xlab = bquote(mu), ylab = "likelihood", main= bquote(sigma == .(sigma)))
}
logLike2(weight, seq(0, 6, .01), 1)
logLike2(weight, seq(0, 6, .01), .5)
