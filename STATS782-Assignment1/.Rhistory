}
if (length(to) < length(from)) {
to <- c(to, 1)
}
} else {
if (length(from) > 1 & length(to) == 1) {
to <- rep(to, length(from))
}
if (length(to) > 1 & length(from) == 1) {
from <- rep(from, length(to))
}
vec <- sort(c(from, to), decreasing = FALSE)
tv <- ceiling(1/vec[length(vec)])
vec1 <- rep(vec, times = tv)
vec2 <-  rep(0:(tv-1) * rep(vec[length(vec)]), each = length(vec))
vec <- vec1 + vec2
mat <- matrix(vec, nrow = 2)
rownames(mat) <- c('from', 'to')
from <- mat["from",]
message(from)
to <- mat["to",]
message(to)
}
}
if (length(from) == length(to)) {
rowBind <- rbind(from, to)
vector <- c(rowBind)
matrix <- matrix(vector, ncol = length(from))
dimnames(matrix) <- list(c('from', 'to'))
matrix <- t(matrix)
matrix[, "from"] <- validateValue("from", matrix[, "from"])
matrix[, "to"] <- validateValue("to", matrix[, "to"])
element <- matrix[, "from"] > matrix[, "to"]
fromValue <- matrix[, "from"][element]
toValue <- matrix[, "to"][element]
matrix[, "from"][element] <- toValue
matrix[, "to"][element] <- fromValue
duplicateUperLimit <- matrix[, "from"] == matrix[, "to"] & matrix[, "from"] == 1
matrix <- matrix[!duplicateUperLimit,]
f <- matrix[, "from"]
t <- matrix[, "to"]
if (f[length(f)] != 1 & t[length(t)] != 1) {
matrix <- rbind(matrix, 1)
}
matrix
}
}
segments(c(.3, .1), .2, rep=TRUE)
segments <- function(from, to, rep = FALSE) {
options(warn = 1)
validateValue <- function(name, value) {
if (any(value > 1)) {
value[value > 1] = 1
warning(paste0(" '", name, "' value(s) larger than 1 reduced to 1 \n"))
}
if (any(value < -1)) {
value[value < -1] = -1
warning(paste0(" '", name, "' value(s) less than -1 raised to -1 \n"))
}
negitiveFloat = value > -1 & value < 0
value[negitiveFloat] = 1 + value[negitiveFloat]
value
}
if (!rep) {
if (length(from) > 1 & length(to) == 1) {
from <- sort(from, decreasing = FALSE)
to <- rep(to, length(from))
}
if (length(to) > 1 & length(from) == 1) {
to <- sort(to, decreasing = FALSE)
from <- rep(from, length(to))
}
} else {
if (length(from) == 1 & length(to) == 1) {
if (from > to) {
temp <- from
from <- to
to <- temp
}
from <- seq(from = from, to = 1, by = to)
to <- seq(from = to, to = 1, by = to)
if (length(to) > length(from)) {
from <- c(from, 1)
}
if (length(to) < length(from)) {
to <- c(to, 1)
}
} else {
if (length(from) > 1 & length(to) == 1) {
to <- rep(to, length(from))
}
if (length(to) > 1 & length(from) == 1) {
from <- rep(from, length(to))
}
vec <- sort(c(from, to), decreasing = FALSE)
tv <- ceiling(1/vec[length(vec)])
vec1 <- rep(vec, times = tv)
vec2 <-  rep(0:(tv-1) * rep(vec[length(vec)]), each = length(vec))
vec <- vec1 + vec2
mat <- matrix(vec, nrow = 2)
rownames(mat) <- c('from', 'to')
message(from)
to <- mat["to",]
}
}
if (length(from) == length(to)) {
rowBind <- rbind(from, to)
vector <- c(rowBind)
matrix <- matrix(vector, ncol = length(from))
dimnames(matrix) <- list(c('from', 'to'))
matrix <- t(matrix)
matrix[, "from"] <- validateValue("from", matrix[, "from"])
matrix[, "to"] <- validateValue("to", matrix[, "to"])
element <- matrix[, "from"] > matrix[, "to"]
fromValue <- matrix[, "from"][element]
toValue <- matrix[, "to"][element]
matrix[, "from"][element] <- toValue
matrix[, "to"][element] <- fromValue
duplicateUperLimit <- matrix[, "from"] == matrix[, "to"] & matrix[, "from"] == 1
matrix <- matrix[!duplicateUperLimit,]
f <- matrix[, "from"]
t <- matrix[, "to"]
if (f[length(f)] != 1 & t[length(t)] != 1) {
matrix <- rbind(matrix, 1)
}
matrix
}
}
segments(c(.4, .3, .1), .2, rep=TRUE)
segments <- function(from, to, rep = FALSE) {
options(warn = 1)
validateValue <- function(name, value) {
if (any(value > 1)) {
value[value > 1] = 1
warning(paste0(" '", name, "' value(s) larger than 1 reduced to 1 \n"))
}
if (any(value < -1)) {
value[value < -1] = -1
warning(paste0(" '", name, "' value(s) less than -1 raised to -1 \n"))
}
negitiveFloat = value > -1 & value < 0
value[negitiveFloat] = 1 + value[negitiveFloat]
value
}
if (!rep) {
if (length(from) > 1 & length(to) == 1) {
from <- sort(from, decreasing = FALSE)
to <- rep(to, length(from))
}
if (length(to) > 1 & length(from) == 1) {
to <- sort(to, decreasing = FALSE)
from <- rep(from, length(to))
}
} else {
if (length(from) == 1 & length(to) == 1) {
if (from > to) {
temp <- from
from <- to
to <- temp
}
from <- seq(from = from, to = 1, by = to)
to <- seq(from = to, to = 1, by = to)
if (length(to) > length(from)) {
from <- c(from, 1)
}
if (length(to) < length(from)) {
to <- c(to, 1)
}
} else {
if (length(from) > 1 & length(to) == 1) {
to <- rep(to, length(from))
}
if (length(to) > 1 & length(from) == 1) {
from <- rep(from, length(to))
}
vec <- sort(c(from, to), decreasing = FALSE)
tv <- ceiling(1/vec[length(vec)])
vec1 <- rep(vec, times = tv)
vec2 <-  rep(0:(tv-1) * rep(vec[length(vec)]), each = length(vec))
vec <- vec1 + vec2
mat <- matrix(vec, nrow = 2)
rownames(mat) <- c('from', 'to')
from <- mat["from",]
to <- mat["to",]
}
}
if (length(from) == length(to)) {
rowBind <- rbind(from, to)
vector <- c(rowBind)
matrix <- matrix(vector, ncol = length(from))
dimnames(matrix) <- list(c('from', 'to'))
matrix <- t(matrix)
matrix[, "from"] <- validateValue("from", matrix[, "from"])
matrix[, "to"] <- validateValue("to", matrix[, "to"])
element <- matrix[, "from"] > matrix[, "to"]
fromValue <- matrix[, "from"][element]
toValue <- matrix[, "to"][element]
matrix[, "from"][element] <- toValue
matrix[, "to"][element] <- fromValue
duplicateUperLimit <- matrix[, "from"] == matrix[, "to"] & matrix[, "from"] == 1
matrix <- matrix[!duplicateUperLimit,]
f <- matrix[, "from"]
t <- matrix[, "to"]
if (f[length(f)] != 1 & t[length(t)] != 1) {
matrix <- rbind(matrix, 1)
}
matrix
}
}
segments(c(.4, .3, .1), .2, rep=TRUE)
segments <- function(from, to, rep = FALSE) {
options(warn = 1)
validateValue <- function(name, value) {
if (any(value > 1)) {
value[value > 1] = 1
warning(paste0(" '", name, "' value(s) larger than 1 reduced to 1 \n"))
}
if (any(value < -1)) {
value[value < -1] = -1
warning(paste0(" '", name, "' value(s) less than -1 raised to -1 \n"))
}
negitiveFloat = value > -1 & value < 0
value[negitiveFloat] = 1 + value[negitiveFloat]
value
}
if (!rep) {
if (length(from) > 1 & length(to) == 1) {
from <- sort(from, decreasing = FALSE)
to <- rep(to, length(from))
}
if (length(to) > 1 & length(from) == 1) {
to <- sort(to, decreasing = FALSE)
from <- rep(from, length(to))
}
} else {
if (length(from) == 1 & length(to) == 1) {
if (from > to) {
temp <- from
from <- to
to <- temp
}
from <- seq(from = from, to = 1, by = to)
to <- seq(from = to, to = 1, by = to)
if (length(to) > length(from)) {
from <- c(from, 1)
}
if (length(to) < length(from)) {
to <- c(to, 1)
}
} else {
if (length(from) > 1 & length(to) == 1) {
to <- rep(to, length(from))
}
if (length(to) > 1 & length(from) == 1) {
from <- rep(from, length(to))
}
vec <- sort(c(from, to), decreasing = FALSE)
tv <- ceiling(1/vec[length(vec)])
vec1 <- rep(vec, times = tv)
vec2 <-  rep(0:(tv-1) * rep(vec[length(vec)]), each = length(vec))
vec <- vec1 + vec2
mat <- matrix(vec, nrow = 2)
rownames(mat) <- c('from', 'to')
from <- mat["from",]
to <- mat["to",]
}
}
# general Code for merging row and columns
if (length(from) == length(to)) {
rowBind <- rbind(from, to)
vector <- c(rowBind)
matrix <- matrix(vector, ncol = length(from))
dimnames(matrix) <- list(c('from', 'to'))
matrix <- t(matrix)
matrix[, "from"] <- validateValue("from", matrix[, "from"])
matrix[, "to"] <- validateValue("to", matrix[, "to"])
element <- matrix[, "from"] > matrix[, "to"]
fromValue <- matrix[, "from"][element]
toValue <- matrix[, "to"][element]
matrix[, "from"][element] <- toValue
matrix[, "to"][element] <- fromValue
# Duplicate row check, takes place for repeat
if (!rep) {
duplicateUperLimit <- matrix[, "from"] == matrix[, "to"] & matrix[, "from"] == 1
matrix <- matrix[!duplicateUperLimit,]
f <- matrix[, "from"]
t <- matrix[, "to"]
if (f[length(f)] != 1 & t[length(t)] != 1) {
matrix <- rbind(matrix, 1)
}
}
matrix
}
}
segments(c(.3, .1), .2, rep=TRUE)
# Duplicate row check, takes place for repeat
if (rep) {
duplicateUperLimit <- matrix[, "from"] == matrix[, "to"] & matrix[, "from"] == 1
matrix <- matrix[!duplicateUperLimit,]
f <- matrix[, "from"]
t <- matrix[, "to"]
if (f[length(f)] != 1 & t[length(t)] != 1) {
matrix <- rbind(matrix, 1)
}
}
segments <- function(from, to, rep = FALSE) {
options(warn = 1)
validateValue <- function(name, value) {
if (any(value > 1)) {
value[value > 1] = 1
warning(paste0(" '", name, "' value(s) larger than 1 reduced to 1 \n"))
}
if (any(value < -1)) {
value[value < -1] = -1
warning(paste0(" '", name, "' value(s) less than -1 raised to -1 \n"))
}
negitiveFloat = value > -1 & value < 0
value[negitiveFloat] = 1 + value[negitiveFloat]
value
}
if (!rep) {
if (length(from) > 1 & length(to) == 1) {
from <- sort(from, decreasing = FALSE)
to <- rep(to, length(from))
}
if (length(to) > 1 & length(from) == 1) {
to <- sort(to, decreasing = FALSE)
from <- rep(from, length(to))
}
} else {
if (length(from) == 1 & length(to) == 1) {
if (from > to) {
temp <- from
from <- to
to <- temp
}
from <- seq(from = from, to = 1, by = to)
to <- seq(from = to, to = 1, by = to)
if (length(to) > length(from)) {
from <- c(from, 1)
}
if (length(to) < length(from)) {
to <- c(to, 1)
}
} else {
if (length(from) > 1 & length(to) == 1) {
to <- rep(to, length(from))
}
if (length(to) > 1 & length(from) == 1) {
from <- rep(from, length(to))
}
vec <- sort(c(from, to), decreasing = FALSE)
tv <- ceiling(1/vec[length(vec)])
vec1 <- rep(vec, times = tv)
vec2 <-  rep(0:(tv-1) * rep(vec[length(vec)]), each = length(vec))
vec <- vec1 + vec2
mat <- matrix(vec, nrow = 2)
rownames(mat) <- c('from', 'to')
from <- mat["from",]
to <- mat["to",]
}
}
# general Code for merging row and columns
if (length(from) == length(to)) {
rowBind <- rbind(from, to)
vector <- c(rowBind)
matrix <- matrix(vector, ncol = length(from))
dimnames(matrix) <- list(c('from', 'to'))
matrix <- t(matrix)
matrix[, "from"] <- validateValue("from", matrix[, "from"])
matrix[, "to"] <- validateValue("to", matrix[, "to"])
element <- matrix[, "from"] > matrix[, "to"]
fromValue <- matrix[, "from"][element]
toValue <- matrix[, "to"][element]
matrix[, "from"][element] <- toValue
matrix[, "to"][element] <- fromValue
# Duplicate row check, takes place for repeat
if (rep) {
duplicateUperLimit <- matrix[, "from"] == matrix[, "to"] & matrix[, "from"] == 1
matrix <- matrix[!duplicateUperLimit,]
f <- matrix[, "from"]
t <- matrix[, "to"]
if (f[length(f)] != 1 & t[length(t)] != 1) {
matrix <- rbind(matrix, 1)
}
}
matrix
}
}
segments(c(.3, .1), .2, rep=TRUE)
knitr::opts_chunk$set(echo = TRUE)
seq(0, 345, by = 15)
2 ^ seq(0, 8)
rep(1:4, rep(4:1))
rep(0:3, times = 4) + rep(1:4, each = 4) * 10
x <- seq(1, 6)
y <- rep(x, times = 3)
z <- paste(x, x, sep = "/")
s <- ifelse(x %% 2 == 0, "-", "")
equationVector <- paste(s, z, sep = "x^")
paste(equationVector, collapse = " + ")
dockless <- read.csv("AustinDockless.csv")
docklessCols <- dockless[ ,c('Trip.Duration', 'Trip.Distance', 'Hour', 'Origin.Cell.ID', 'Destination.Cell.ID')]
docklessCols
distanceOrderbyLongest <- sort(docklessCols$Trip.Distance, decreasing = TRUE)
top10Distance <- distanceOrderbyLongest[1:10]
top10Distance
tripAbove19km <- docklessCols[which(docklessCols$Trip.Distance > 19000), c('Origin.Cell.ID', 'Destination.Cell.ID') ]
tripAbove19km
tripBtw0to8 <- docklessCols[which(docklessCols$Hour >= 0 & docklessCols$Hour <= 8),]
tripBtw0to8LongestDistance <- sort(tripBtw0to8$Trip.Distance, decreasing = TRUE)
topDistanceTripBtw0to8 <- tripBtw0to8LongestDistance[1]
topDistanceTripBtw0to8
docklessCols['Trip.Speed'] <- docklessCols$Trip.Distance / docklessCols$Trip.Duration
tripOrderByFastestSpeed <- docklessCols[order(docklessCols$Trip.Speed, decreasing = TRUE), c('Trip.Distance', 'Trip.Speed')]
top10FastestSpeed <- tripOrderByFastestSpeed[1:10,]
top10FastestSpeed
Trip.Distance <- docklessCols$Trip.Distance
distMean <- mean(Trip.Distance)
distMean
distSD <- sd(Trip.Distance)
distSD
distMedian <- median(Trip.Distance)
distMedian
distQuartiles <- quantile(Trip.Distance, seq(.25, .75, .25))
distQuartiles
set.seed(1234)
randomDistance10000 <- rnorm(10000, distMean, distSD)
randomDistanceMedian <- median(randomDistance)
randQuartiles <- quantile(randomDistance10000, seq(.25, .75, .25))
randQuartiles
set.seed(1234)
randomDistance1000000 <- rnorm(1000000, distMean, distSD)
randomizedDistanceMatrix <- matrix(randomDistance1000000, 10000)
randQuartiles <- numeric(ncol(randomizedDistanceMatrix))
for(i in 1:ncol(randomizedDistanceMatrix)) {
randQuartiles[i] <- quantile(randomizedDistanceMatrix[, i], c(.75))
}
randQuartiles
pval = sum(distQuartiles[which(randQuartiles < distQuartiles[2])])
pval
hist(Trip.Distance)
hist(randomDistance1000000)
segments <- function(from, to, rep = FALSE) {
options(warn = 1)
if (from > 1) {
from = 1
warning(" 'from' value(s) larger than 1 reduced to 1 \n")
}
if (from < -1) {
from = 1
warning(" 'from' value(s) less than -1 raised to -1 \n")
}
if (to > 1) {
to = 1
warning(" 'to' value(s) larger than 1 reduced to 1 \n")
}
if (to < -1) {
to = 1
warning(" 'to' value(s) less than -1 raised to -1 \n")
}
c(from = from, to = to)
}
segments(.1, 1.2)
segments(-1.2, .1)
View(dockless)
knitr::opts_chunk$set(echo = TRUE)
seq(0, 345, by = 15)
2 ^ seq(0, 8)
rep(1:4, rep(4:1))
rep(0:3, times = 4) + rep(1:4, each = 4) * 10
x <- seq(1, 6)
y <- rep(x, times = 3)
z <- paste(x, x, sep = "/")
s <- ifelse(x %% 2 == 0, "-", "")
equationVector <- paste(s, z, sep = "x^")
paste(equationVector, collapse = " + ")
dbinom(8.85, length(x), 0:10)
dbinom?
?dbinom
dpios
?dpios
?dpiom
dpios
?dpios
?dpois
?pbinom
pbinom(.7, 13, seq(.1, .9, .01))
gp = pbinom(.7, 13, seq(.1, .9, .01))
plot(gp, type = 'l')
gp = pbinom(.07, 13, seq(.1, .9, .01))
gp = pbinom(.07, 13, seq(.1, .9, .01))
plot(gp, type = 'l')
dbinom(10:13, 13, .7)
sumdbinom(10:13, 13, .7)
sum(dbinom(10:13, 13, .7))
sum(dbinom(10:13, 13, .6))
sum(dbinom(11:13, 13, .7))
sum(dbinom(12:13, 13, .7))
sum(dbinom(1:12, 13, .95))
sum(dbinom(0:11, 13, .95))
sum(dbinom(10:13, 13, .7))
sum(dpois(.3, 6))
sum(dpois(0:3, 6))
days = c(1,3,2,2,5,0,1,4,3,3,4,1,4,1,1,1,0,1,2,1,0,0,2,1,0,0,4,1,1,1)
sum(days)
2.5 * 50
2.5*30
sum(dpois(0:72, 75))
sum(dpois(0:69, 75))
sum(dpois(0:60, 75))
sum(dpois(0:61, 75))
